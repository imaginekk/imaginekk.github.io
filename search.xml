<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2023/07/28/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title>Monitor</title>
    <url>/2023/07/28/JUC/</url>
    <content><![CDATA[<h2 id="Monitor-概念"><a href="#Monitor-概念" class="headerlink" title="Monitor 概念"></a>Monitor 概念</h2><h3 id="Java-对象头"><a href="#Java-对象头" class="headerlink" title="Java 对象头"></a>Java 对象头</h3><p>以 32 位虚拟机为例</p>
<p>普通对象</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">|<span class="params">--------------------------------------------------------------</span>|</span><br><span class="line">|<span class="params">                      Object Header (64 bits)                 </span>|</span><br><span class="line">|<span class="params">------------------------------------</span>|-------------------------|<span class="params"></span></span><br><span class="line"><span class="params"></span>|                <span class="title class_">Mark</span> <span class="title class_">Word</span> (<span class="number">32</span> bits) |<span class="params">  Klass Word (32 bits)   </span>|</span><br><span class="line">|<span class="params">------------------------------------</span>|-------------------------|<span class="params"></span></span><br></pre></td></tr></table></figure>

<p>数组对象</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">|<span class="params">---------------------------------------------------------------------------------</span>|</span><br><span class="line">|<span class="params">                          Object Header (96 bits)                                </span>|</span><br><span class="line">|<span class="params">--------------------------------</span>|-----------------------|<span class="params">------------------------</span>|</span><br><span class="line">|<span class="params">        Mark Word(32bits)       </span>|    <span class="title class_">Klass</span> <span class="title class_">Word</span>(32bits) |<span class="params">   array length(32bits) </span>|</span><br><span class="line">|<span class="params">--------------------------------</span>|-----------------------|<span class="params">------------------------</span>|</span><br></pre></td></tr></table></figure>

<p>其中 Mark Word 结构为</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">|<span class="params">-------------------------------------------------------</span>|--------------------|<span class="params"></span></span><br><span class="line"><span class="params"></span>|                     <span class="title class_">Mark</span> <span class="title class_">Word</span> (<span class="number">32</span> bits)               |<span class="params">        State       </span>|</span><br><span class="line">|<span class="params">-------------------------------------------------------</span>|--------------------|<span class="params"></span></span><br><span class="line"><span class="params"></span>|      <span class="symbol">hashcode:</span><span class="number">25</span> |<span class="params"> age:4 </span>| <span class="symbol">biased_lock:</span><span class="number">0</span>         |<span class="params"> 01 </span>|        <span class="title class_">Normal</span>      |<span class="params"></span></span><br><span class="line"><span class="params"></span>|-------------------------------------------------------|<span class="params">--------------------</span>|</span><br><span class="line">|<span class="params">      thread:23 </span>| <span class="symbol">epoch:</span><span class="number">2</span> |<span class="params"> age:4 </span>| <span class="symbol">biased_lock:</span><span class="number">1</span> |<span class="params"> 01 </span>|        <span class="title class_">Biased</span>      |<span class="params"></span></span><br><span class="line"><span class="params"></span>|-------------------------------------------------------|<span class="params">--------------------</span>|</span><br><span class="line">|<span class="params">                ptr_to_lock_record:30             </span>| <span class="number">00</span> |<span class="params"> Lightweight Locked </span>|</span><br><span class="line">|<span class="params">-------------------------------------------------------</span>|--------------------|<span class="params"></span></span><br><span class="line"><span class="params"></span>|            <span class="symbol">ptr_to_heavyweight_monitor:</span><span class="number">30</span>         |<span class="params"> 10 </span>| <span class="title class_">Heavyweight</span> <span class="title class_">Locked</span> |<span class="params"></span></span><br><span class="line"><span class="params"></span>|-------------------------------------------------------|<span class="params">--------------------</span>|</span><br><span class="line">|<span class="params">                                                  </span>| <span class="number">11</span> |<span class="params">    Marked <span class="keyword">for</span> GC   </span>|</span><br><span class="line">|<span class="params">-------------------------------------------------------</span>|--------------------|<span class="params"></span></span><br></pre></td></tr></table></figure>

<p>64 位虚拟机 Mark Word</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">|<span class="params">--------------------------------------------------------------------</span>|--------------------|<span class="params"></span></span><br><span class="line"><span class="params"></span>|                        <span class="title class_">Mark</span> <span class="title class_">Word</span> (<span class="number">64</span> bits)                         |<span class="params">        State       </span>|</span><br><span class="line">|<span class="params">--------------------------------------------------------------------</span>|--------------------|<span class="params"></span></span><br><span class="line"><span class="params"></span>|   <span class="symbol">unused:</span><span class="number">25</span> |<span class="params"> hashcode:31 </span>| <span class="symbol">unused:</span><span class="number">1</span> |<span class="params"> age:4 </span>| <span class="symbol">biased_lock:</span><span class="number">0</span> |<span class="params"> 01  </span>|        <span class="title class_">Normal</span>      |<span class="params"></span></span><br><span class="line"><span class="params"></span>|--------------------------------------------------------------------|<span class="params">--------------------</span>|</span><br><span class="line">|<span class="params">       thread:54 </span>| <span class="symbol">epoch:</span><span class="number">2</span> |<span class="params"> unused:1 </span>| <span class="symbol">age:</span><span class="number">4</span> |<span class="params"> biased_lock:1 </span>| <span class="number">01</span>  |<span class="params">        Biased      </span>|</span><br><span class="line">|<span class="params">--------------------------------------------------------------------</span>|--------------------|<span class="params"></span></span><br><span class="line"><span class="params"></span>|                   <span class="symbol">ptr_to_lock_record:</span><span class="number">62</span>                      |<span class="params"> 00  </span>| <span class="title class_">Lightweight</span> <span class="title class_">Locked</span> |<span class="params"></span></span><br><span class="line"><span class="params"></span>|--------------------------------------------------------------------|<span class="params">--------------------</span>|</span><br><span class="line">|<span class="params">                   ptr_to_heavyweight_monitor:62              </span>| <span class="number">10</span>  |<span class="params"> Heavyweight Locked </span>|</span><br><span class="line">|<span class="params">--------------------------------------------------------------------</span>|--------------------|<span class="params"></span></span><br><span class="line"><span class="params"></span>|                                                              |<span class="params">11   </span>|     <span class="title class_">Marked</span> <span class="keyword">for</span> <span class="variable constant_">GC</span>  |<span class="params"></span></span><br><span class="line"><span class="params"></span>|--------------------------------------------------------------------|<span class="params">--------------------</span>|</span><br></pre></td></tr></table></figure>

<h2 id="Monitor-原理"><a href="#Monitor-原理" class="headerlink" title="Monitor 原理"></a>Monitor 原理</h2><p>Monitor 被翻译为<strong>监视器</strong>或<strong>管程</strong><br>每个 Java 对象都可以关联一个 Monitor 对象，如果使用 synchronized 给对象上锁（重量级）之后，该对象头的<br>Mark Word 中就被设置指向 Monitor 对象的指针</p>
<p>Monitor 结构如下<br><img src="https://note-461f.obs.cn-south-1.myhuaweicloud.com/img/20230721114234.png"></p>
<ul>
<li>刚开始 Monitor 中 Owner 为 null</li>
<li>当 Thread-2 执行 synchronized(obj) 就会将 Monitor 的所有者 Owner 置为 Thread-2，Monitor中只能有一个 Owner</li>
<li>在 Thread-2 上锁的过程中，如果 Thread-3，Thread-4，Thread-5 也来执行 synchronized(obj)，就会进入EntryList BLOCKED</li>
<li>Thread-2 执行完同步代码块的内容，然后唤醒 EntryList 中等待的线程来竞争锁，竞争的时是非公平的</li>
<li>图中 WaitSet 中的 Thread-0，Thread-1 是之前获得过锁，但条件不满足进入 WAITING 状态的线程，后面讲wait-notify 时会分析</li>
</ul>
<blockquote>
<p>注意：</p>
<ul>
<li>synchronized 必须是进入同一个对象的 monitor 才有上述的效果</li>
<li>不加 synchronized 的对象不会关联监视器，不遵从以上规则</li>
</ul>
</blockquote>
<pre class="mermaid">graph LR
    A(开始) -->B(执行 monitorenter)
    B --> C{锁计数器是否为0}
   
    C --是--> D(锁计数器加1)
    D --> F(结束)
    C --否--> F</pre>



<h2 id="synchronized优化"><a href="#synchronized优化" class="headerlink" title="synchronized优化"></a>synchronized优化</h2><h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>轻量级锁的使用场景：如果一个对象虽然有多线程要加锁，但加锁的时间是错开的（也就是没有竞争），那么可以使用轻量级锁来优化。<br>轻量级锁对使用者是透明的，即语法仍然是 synchronized<br>假设有两个方法同步块，利用同一个对象加锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">synchronized</span>( obj ) &#123;</span><br><span class="line">		<span class="comment">// 同步块 A</span></span><br><span class="line">		method2();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">synchronized</span>( obj ) &#123;</span><br><span class="line">		<span class="comment">// 同步块 B</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>创建锁记录（Lock Record）对象，每个线程都的栈帧都会包含一个锁记录的结构，内部可以存储锁定对象的Mark Word</p>
<p><img src="https://note-461f.obs.cn-south-1.myhuaweicloud.com/img/20230721172232.png" alt="image.png"></p>
</li>
<li><p>让锁记录中 Object reference 指向锁对象，并尝试用 cas 替换 Object 的 Mark Word，将 Mark Word 的值存入锁记录</p>
<p><img src="https://note-461f.obs.cn-south-1.myhuaweicloud.com/img/20230721172828.png" alt="image.png"></p>
</li>
<li><p>如果 cas 替换成功，对象头中存储了 锁记录地址和状态 00 ，表示由该线程给对象加锁，这时图示如下</p>
<p><img src="https://note-461f.obs.cn-south-1.myhuaweicloud.com/img/20230721173056.png" alt="Uploading file...64t70"></p>
</li>
<li><p>如果 cas 失败，有两种情况</p>
<ul>
<li>如果是其它线程已经持有了该 Object 的轻量级锁，这时表明有竞争，进入锁膨胀过程</li>
<li>如果是自己执行了 synchronized 锁重入，那么再添加一条 Lock Record 作为重入的计数<br><img src="https://note-461f.obs.cn-south-1.myhuaweicloud.com/img/20230721173420.png" alt="image.png"></li>
</ul>
</li>
<li><p>当退出 synchronized 代码块（解锁时）如果有取值为 null 的锁记录，表示有重入，这时重置锁记录，表示重入计数减一</p>
</li>
</ul>
<p><img src="https://note-461f.obs.cn-south-1.myhuaweicloud.com/img/20230721173056.png" alt="Uploading file...64t70"></p>
<ul>
<li>当退出 synchronized 代码块（解锁时）锁记录的值不为 null，这时使用 cas 将 Mark Word 的值恢复给对象头<ul>
<li>成功，则解锁成功</li>
<li>失败，说明轻量级锁进行了锁膨胀或已经升级为重量级锁，进入重量级锁解锁流程</li>
</ul>
</li>
</ul>
<h3 id="锁膨胀"><a href="#锁膨胀" class="headerlink" title="锁膨胀"></a>锁膨胀</h3><p>如果在尝试加轻量级锁的过程中，CAS 操作无法成功，这时一种情况就是有其它线程为此对象加上了轻量级锁（有竞争），这时需要进行锁膨胀，将轻量级锁变为重量级锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">synchronized</span>( obj ) &#123;</span><br><span class="line">	<span class="comment">// 同步块</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>当 Thread-1 进行轻量级加锁时，Thread-0 已经对该对象加了轻量级锁<br><img src="https://note-461f.obs.cn-south-1.myhuaweicloud.com/img/20230721203222.png" alt="image.png"></p>
</li>
<li><p>这时 Thread-1 加轻量级锁失败，进入锁膨胀流程</p>
<ul>
<li>即为 Object 对象申请 Monitor 锁，让 Object 指向重量级锁地址</li>
<li>然后自己进入 Monitor 的 EntryList BLOCKED<br><img src="https://note-461f.obs.cn-south-1.myhuaweicloud.com/img/20230721203742.png" alt="image.png"></li>
</ul>
</li>
</ul>
<h3 id="自旋"><a href="#自旋" class="headerlink" title="自旋"></a>自旋</h3><p>重量级锁竞争的时候，还可以使用自旋来进行优化，如果当前线程自旋成功（即这时候持锁线程已经退出了同步<br>块，释放了锁），这时当前线程就可以避免阻塞。</p>
<ul>
<li>自旋会占用 CPU 时间，单核 CPU 自旋就是浪费，多核 CPU 自旋才能发挥优势。</li>
<li>在 Java 6 之后自旋锁是自适应的，比如对象刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能性会高，就多自旋几次；反之，就少自旋甚至不自旋，总之，比较智能。</li>
<li>Java 7 之后不能控制是否开启自旋功能</li>
</ul>
<h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>轻量级锁在没有竞争时（就自己这个线程），每次重入仍然需要执行 CAS 操作。<br>Java 6 中引入了偏向锁来做进一步优化：只有第一次使用 CAS 将线程 ID 设置到对象的 Mark Word 头，之后发现这个线程 ID 是自己的就表示没有竞争，不用重新 CAS。以后只要不发生竞争，这个对象就归该线程所有</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">synchronized</span>( obj ) &#123;</span><br><span class="line">		<span class="comment">// 同步块 A</span></span><br><span class="line">		m2();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">synchronized</span>( obj ) &#123;</span><br><span class="line">		<span class="comment">// 同步块 B</span></span><br><span class="line">		m3();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m3</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">synchronized</span>( obj ) &#123;</span><br><span class="line">        <span class="comment">// 同步块 C</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<pre class="mermaid">graph LR
    subgraph 轻量级锁
    id1["m1内调用synchronized(obj)"]--用 锁记录 替换 markword-->对象
    id1["m1内调用synchronized(obj)"]-.生成锁记录.->id1
    id2["m1内调用synchronized(obj)"]--用 锁记录 替换 markword-->对象
    id2["m1内调用synchronized(obj)"]-.生成锁记录.->id2
    id3["m1内调用synchronized(obj)"]--用 锁记录 替换 markword-->对象
    id3["m1内调用synchronized(obj)"]-.生成锁记录.->id3
    end</pre>

<pre class="mermaid">graph LR
    subgraph 偏向锁
    id1["m1内调用synchronized(obj)"]--用 ThreadID 替换 markword-->对象
    id2["m1内调用synchronized(obj)"]--检查 ThreadID 是否是自己-->对象
    id3["m1内调用synchronized(obj)"]--检查 ThreadID 是否是自己-->对象
    end</pre>

<p>一个对象创建时：</p>
<ul>
<li>如果开启了偏向锁（默认开启），那么对象创建后，markword 值为 0x05 即最后 3 位为 101，这时它的thread、epoch、age 都为 0</li>
<li>偏向锁是默认是延迟的，不会在程序启动时立即生效，如果想避免延迟，可以加 VM 参数 -XX:BiasedLockingStartupDelay&#x3D;0 来禁用延迟</li>
<li>如果没有开启偏向锁，那么对象创建后，markword 值为 0x01 即最后 3 位为 001，这时它的 hashcode、age 都为 0，第一次用到 hashcode 时才会赋值</li>
</ul>
<h4 id="撤销-调用对象-hashCode"><a href="#撤销-调用对象-hashCode" class="headerlink" title="撤销 - 调用对象 hashCode"></a>撤销 - 调用对象 hashCode</h4><p>调用了对象的 hashCode，但偏向锁的对象 MarkWord 中存储的是线程 id，如果调用 hashCode 会导致偏向锁被撤销变为正常对象</p>
<ul>
<li>轻量级锁会在锁记录中记录 hashCode</li>
<li>重量级锁会在 Monitor 中记录 hashCode</li>
</ul>
<h4 id="撤销-其它线程使用对象"><a href="#撤销-其它线程使用对象" class="headerlink" title="撤销 - 其它线程使用对象"></a>撤销 - 其它线程使用对象</h4><p>当有其它线程使用偏向锁对象时，会将偏向锁升级为轻量级锁</p>
<h4 id="撤销-调用-wait-notify"><a href="#撤销-调用-wait-notify" class="headerlink" title="撤销 - 调用 wait&#x2F;notify"></a>撤销 - 调用 wait&#x2F;notify</h4><h4 id="批量重偏向"><a href="#批量重偏向" class="headerlink" title="批量重偏向"></a>批量重偏向</h4><p>如果对象虽然被多个线程访问，但没有竞争，这时偏向了线程 T1 的对象仍有机会重新偏向 T2，重偏向会重置对象的 Thread ID<br>当撤销偏向锁阈值超过 20 次后，jvm 会这样觉得，我是不是偏向错了呢，于是会在给这些对象加锁时重新偏向至加锁线程</p>
<h4 id="批量撤销"><a href="#批量撤销" class="headerlink" title="批量撤销"></a>批量撤销</h4><p>当撤销偏向锁阈值超过 40 次后，jvm 会这样觉得，自己确实偏向错了，根本就不该偏向。于是整个类的所有对象都会变为不可偏向的，新建的对象也是不可偏向的</p>
]]></content>
      <tags>
        <tag>JUC</tag>
      </tags>
  </entry>
  <entry>
    <title>Java集合</title>
    <url>/2023/08/01/%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<h3 id="常见集合"><a href="#常见集合" class="headerlink" title="常见集合"></a>常见集合</h3><p>集合相关类和接口都在java.util中，主要分为3种：List（列表）、Map（映射）、Set(集)。<br><img src="https://note-461f.obs.cn-south-1.myhuaweicloud.com/img/20230801154435.png" alt="image.png"><br>其中<code>Collection</code>是集合<code>List</code>、<code>Set</code>的父接口，它主要有两个子接口：</p>
<ul>
<li><code>List</code>：存储的元素有序，可重复。</li>
<li><code>Set</code>：存储的元素不无序，不可重复。<br><code>Map</code>是另外的接口，是键值对映射结构的集合。</li>
</ul>
<h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><h5 id="ArrayList和LinkedList有什么区别？"><a href="#ArrayList和LinkedList有什么区别？" class="headerlink" title="ArrayList和LinkedList有什么区别？"></a>ArrayList和LinkedList有什么区别？</h5><p>（1）数据结构不同</p>
<ul>
<li>ArrayList基于数组实现</li>
<li>LinkedList基于双向链表实现<br><img src="https://note-461f.obs.cn-south-1.myhuaweicloud.com/img/20230801155559.png" alt="image.png"><br>(2) 多数情况下，ArrayList更利于查找，LinkedList更利于增删</li>
<li>ArrayList基于数组实现，get(int index)可以直接通过数组下标获取，时间复杂度是O(1)；LinkedList基于链表实现，get(int index)需要遍历链表，时间复杂度是O(n)；当然，get(E element)这种查找，两种集合都需要遍历，时间复杂度都是O(n)。</li>
<li>ArrayList增删如果是数组末尾的位置，直接插入或者删除就可以了，但是如果插入中间的位置，就需要把插入位置后的元素都向前或者向后移动，甚至还有可能触发扩容；双向链表的插入和删除只需要改变前驱节点、后继节点和插入节点的指向就行了，不需要移动元素。<br><img src="https://note-461f.obs.cn-south-1.myhuaweicloud.com/img/20230801162352.png" alt="image.png"><br>（3）是否支持随机访问</li>
<li>ArrayList基于数组，所以它可以根据下标查找，支持随机访问</li>
<li>LinkedList基于链表，所以它没法根据序号直接获取元素<br>（4）内存占用，ArrayList基于数组，是一块连续的内存空间，LinkedList基于链表，内存空间不连续，它们在空间占用上都有一些额外的消耗：</li>
<li>ArrayList是预先定义好的数组，可能会有空的内存空间，存在一定空间浪费</li>
<li>LinkedList每个节点，需要存储前驱和后继，所以每个节点会占用更多的空间</li>
</ul>
<p>ArrayList是基于数组的集合，数组的容量是在定义的时候确定的如果没有指明数组的长度初始容量为0，在第一次添加数据的时候才会初始化容量为10，如果数组满了，再插入，就会数组溢出。所以在插入时候，会先检查是否需要扩容，如果当前容量+1超过数组长度，就会进行扩容。<br>ArrayList的扩容是创建一个<strong>1.5倍</strong>的新数组，然后把原数组的值拷贝过去。<br><img src="https://note-461f.obs.cn-south-1.myhuaweicloud.com/img/20230801163211.png" alt="image.png"></p>
<h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><h5 id="HashMap的数据结构"><a href="#HashMap的数据结构" class="headerlink" title="HashMap的数据结构"></a>HashMap的数据结构</h5><p>JDK1.8的数据结构是<code>数组</code>+<code>链表</code>+<code>红黑树</code>。<br>其中，桶数组是用来存储数据元素，链表是用来解决冲突，红黑树是为了提高查询的效率。<br><img src="https://note-461f.obs.cn-south-1.myhuaweicloud.com/img/20230801182620.png" alt="image.png"></p>
<ul>
<li>数据元素通过映射关系，也就是散列函数，映射到桶数组对应索引的位置</li>
<li>如果发生冲突，从冲突的位置拉一个链表，插入冲突的元素</li>
<li>如果链表长度&gt;8&amp;数组大小&gt;&#x3D;64，链表转为红黑树</li>
<li>如果红黑树节点个数&lt;6 ，转为链表</li>
</ul>
<h5 id="HashMap的put流程"><a href="#HashMap的put流程" class="headerlink" title="HashMap的put流程"></a>HashMap的put流程</h5><p><img src="https://note-461f.obs.cn-south-1.myhuaweicloud.com/img/20230801175716.png" alt="image.png"></p>
<ol>
<li>首先进行哈希值的扰动，获取一个新的哈希值。</li>
<li>判断tab是否位空或者长度为0，如果是则进行扩容操作。</li>
<li>根据哈希值计算下标，如果对应小标正好没有存放数据，则直接插入即可否则需要覆盖。</li>
<li>判断tab[i]是否为树节点，否则向链表中插入数据，是则向树中插入节点。</li>
<li>如果链表中插入节点的时候，链表长度大于等于8，则需要把链表转换为红黑树。</li>
<li>最后所有元素处理完成后，判断是否超过阈值，超过则扩容。</li>
</ol>
<h5 id="HashMap查找元素"><a href="#HashMap查找元素" class="headerlink" title="HashMap查找元素"></a>HashMap查找元素</h5><p><img src="https://note-461f.obs.cn-south-1.myhuaweicloud.com/img/20230801180150.png" alt="image.png"></p>
<p>HashMap的查找就简单很多：</p>
<ol>
<li>使用扰动函数，获取新的哈希值</li>
<li>计算数组下标，获取节点</li>
<li>当前节点和key匹配，直接返回</li>
<li>否则，当前节点是否为树节点，查找红黑树</li>
<li>否则，遍历链表查找</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>一条SQL语句的执行过程</title>
    <url>/2023/08/01/%E4%B8%80%E6%9D%A1SQL%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%89%A7%E8%A1%8C/</url>
    <content><![CDATA[<h2 id="一条SQL语句的执行过程"><a href="#一条SQL语句的执行过程" class="headerlink" title="一条SQL语句的执行过程"></a>一条SQL语句的执行过程</h2><p><img src="https://note-461f.obs.cn-south-1.myhuaweicloud.com/img/20230801222601.png" alt="image.png"></p>
<h3 id="1-连接器"><a href="#1-连接器" class="headerlink" title="1. 连接器"></a>1. 连接器</h3><p>连接器主要和身份认证和权限相关的功能相关，就好比一个级别很高的门卫一样。</p>
<p>主要负责用户登录数据库，进行用户的身份认证，包括校验账户密码，权限等操作，如果用户账户密码已通过，连接器会到权限表中查询该用户的所有权限，之后在这个连接里的权限逻辑判断都是会依赖此时读取到的权限数据，也就是说，后续只要这个连接不断开，即使管理员修改了该用户的权限，该用户也是不受影响的。</p>
<h3 id="2-查询缓存-MySQL-8-0-版本后移除"><a href="#2-查询缓存-MySQL-8-0-版本后移除" class="headerlink" title="2. 查询缓存(MySQL 8.0 版本后移除)"></a>2. 查询缓存(MySQL 8.0 版本后移除)</h3><p>查询缓存主要用来缓存我们所执行的 SELECT 语句以及该语句的结果集。</p>
<p>连接建立后，执行查询语句的时候，会先查询缓存，MySQL 会先校验这个 SQL 是否执行过，以 Key-Value 的形式缓存在内存中，Key 是查询语句，Value 是结果集。如果缓存 key 被命中，就会直接返回给客户端，如果没有命中，就会执行后续的操作，完成后也会把结果缓存起来，方便下一次调用。当然在真正执行缓存查询的时候还是会校验用户的权限，是否有该表的查询条件。</p>
<p>MySQL 查询不建议使用缓存，因为查询缓存失效在实际业务场景中可能会非常频繁，假如你对一个表更新的话，这个表上的所有的查询缓存都会被清空。对于不经常更新的数据来说，使用缓存还是可以的。</p>
<p>所以，一般在大多数情况下我们都是不推荐去使用查询缓存的。</p>
<p>MySQL 8.0 版本后删除了缓存的功能，官方也是认为该功能在实际的应用场景比较少，所以干脆直接删掉了。</p>
<h3 id="3-分析器"><a href="#3-分析器" class="headerlink" title="3. 分析器"></a>3. 分析器</h3><p>MySQL 没有命中缓存，那么就会进入分析器，分析器主要是用来分析 SQL 语句是来干嘛的，分析器也会分为几步：</p>
<p><strong>第一步，词法分析</strong>，一条 SQL 语句有多个字符串组成，首先要提取关键字，比如 select，提出查询的表，提出字段名，提出查询条件等等。做完这些操作后，就会进入第二步。</p>
<p><strong>第二步，语法分析</strong>，主要就是判断你输入的 SQL 是否正确，是否符合 MySQL 的语法。</p>
<p>完成这 2 步之后，MySQL 就准备开始执行了，但是如何执行，怎么执行是最好的结果呢？这个时候就需要优化器上场了。</p>
<h3 id="4-优化器"><a href="#4-优化器" class="headerlink" title="4. 优化器"></a>4. 优化器</h3><p>优化器的作用就是它认为的最优的执行方案去执行（有时候可能也不是最优，这篇文章涉及对这部分知识的深入讲解），比如多个索引的时候该如何选择索引，多表查询的时候如何选择关联顺序等。</p>
<p>可以说，经过了优化器之后可以说这个语句具体该如何执行就已经定下来。</p>
<h3 id="5-执行器"><a href="#5-执行器" class="headerlink" title="5. 执行器"></a>5. 执行器</h3><p>当选择了执行方案后，MySQL 就准备开始执行了，首先执行前会校验该用户有没有权限，如果没有权限，就会返回错误信息，如果有权限，就会去调用引擎的接口，返回接口执行的结果。</p>
<p>结合上面的说明，我们分析下这个语句的执行流程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from tb_student  A where A.age=&#x27;18&#x27; and A.name=&#x27; 张三 &#x27;;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>先检查该语句是否有权限，如果没有权限，直接返回错误信息，如果有权限，在 MySQL8.0 版本以前，会先查询缓存，以这条 SQL 语句为 key 在内存中查询是否有结果，如果有直接缓存，如果没有，执行下一步。</p>
</li>
<li><p>通过分析器进行词法分析，提取 SQL 语句的关键元素，比如提取上面这个语句是查询 select，提取需要查询的表名为 tb_student，需要查询所有的列，查询条件是这个表的 id&#x3D;’1’。然后判断这个 SQL 语句是否有语法错误，比如关键词是否正确等等，如果检查没问题就执行下一步。</p>
</li>
<li><p>接下来就是优化器进行确定执行方案，上面的 SQL 语句，可以有两种执行方案：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a.先查询学生表中姓名为“张三”的学生，然后判断是否年龄是 18。</span><br><span class="line">b.先找出学生中年龄 18 岁的学生，然后再查询姓名为“张三”的学生。</span><br></pre></td></tr></table></figure>

<p>那么优化器根据自己的优化算法进行选择执行效率最好的一个方案（优化器认为，有时候不一定最好）。那么确认了执行计划后就准备开始执行了。</p>
</li>
<li><p>进行权限校验，如果没有权限就会返回错误信息，如果有权限就会调用数据库引擎接口，返回引擎的执行结果</p>
</li>
</ul>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
</search>
